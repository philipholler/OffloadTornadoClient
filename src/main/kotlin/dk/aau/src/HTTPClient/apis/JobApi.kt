/**
 * Offloading
 * Semester project for 7th semester at Aalborg University
 *
 * OpenAPI spec version: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
package io.swagger.client.apis

import io.swagger.client.models.Job
import io.swagger.client.models.UserCredentials

import io.swagger.client.infrastructure.*

class JobApi(basePath: kotlin.String = "http://localhost:8080") : ApiClient(basePath) {

    /**
     * 
     * Deletes a job
     * @param jobId Job to be deleted 
     * @param userCredentials  
     * @return void
     */
    fun deleteJob(jobId: kotlin.Long, userCredentials: UserCredentials): Unit {
        
        val localVariableConfig = RequestConfig(
                RequestMethod.DELETE,
                "/jobs/{userCredentials}/{jobId}".replace("{" + "jobId" + "}", "$jobId").replace("{" + "userCredentials" + "}", "$userCredentials")
        )
        val response = request<Any?>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * Gets the job files
     * @param jobId Job to get files from 
     * @param userCredentials  
     * @return kotlin.Array<kotlin.Byte>
     */
    @Suppress("UNCHECKED_CAST")
    fun getJobFiles(jobId: kotlin.Long, userCredentials: UserCredentials): kotlin.Array<kotlin.Byte> {
        
        val localVariableConfig = RequestConfig(
                RequestMethod.GET,
                "/jobs/{userCredentials}/{jobId}/files".replace("{" + "jobId" + "}", "$jobId").replace("{" + "userCredentials" + "}", "$userCredentials")
        )
        val response = request<kotlin.Array<kotlin.Byte>>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as kotlin.Array<kotlin.Byte>
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * Gets the job result
     * @param jobId Job to query result for 
     * @param userCredentials  
     * @return kotlin.Array<kotlin.Byte>
     */
    @Suppress("UNCHECKED_CAST")
    fun getJobResult(jobId: kotlin.Long, userCredentials: UserCredentials): kotlin.Array<kotlin.Byte> {
        
        val localVariableConfig = RequestConfig(
                RequestMethod.GET,
                "/jobs/{userCredentials}/{jobId}/result".replace("{" + "jobId" + "}", "$jobId").replace("{" + "userCredentials" + "}", "$userCredentials")
        )
        val response = request<kotlin.Array<kotlin.Byte>>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as kotlin.Array<kotlin.Byte>
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * Returns all jobs uploaded by given user
     * @param userCredentials Username of user to filter jobs by 
     * @return kotlin.Array<Job>
     */
    @Suppress("UNCHECKED_CAST")
    fun getJobsForUser(userCredentials: UserCredentials): kotlin.Array<Job> {
        
        val localVariableConfig = RequestConfig(
                RequestMethod.GET,
                "/jobs/{userCredentials}".replace("{" + "userCredentials" + "}", "$userCredentials")
        )
        val response = request<kotlin.Array<Job>>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as kotlin.Array<Job>
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * Uploads a job to be computed
     * @param requestedWorkers  
     * @param userCredentials  
     * @param jobfile  (optional)
     * @return void
     */
    fun postJob(requestedWorkers: kotlin.Int, userCredentials: UserCredentials, jobfile: kotlin.Array<kotlin.Byte>? = null): Unit {
        val localVariableBody: kotlin.Any? = mapOf("jobfile" to "$jobfile")
        val localVariableQuery: MultiValueMap = mapOf("requestedWorkers" to listOf("$requestedWorkers"))
        val localVariableHeaders: kotlin.collections.Map<kotlin.String, kotlin.String> = mapOf("Content-Type" to "multipart/form-data")
        val localVariableConfig = RequestConfig(
                RequestMethod.POST,
                "/jobs/{userCredentials}".replace("{" + "userCredentials" + "}", "$userCredentials"), query = localVariableQuery, headers = localVariableHeaders
        )
        val response = request<Any?>(
                localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
}
